package com.mthree.services;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Optional;
import java.lang.*;
import com.mthree.daos.TradesOp;
import com.mthree.models.Trade;
import java.time.LocalDateTime;
public class TradeOpImpl implements TradesOp {

	@Override
	public double  openPrice(ArrayList<Trade> trades, String sym) {
		// TODO Auto-generated method stub
		//'AT' An automatic trade generated by the SETS system through the order book//use localtime//make a list of dates  and then a stream 
		LocalDateTime refDate = null;
		ArrayList<LocalDateTime> listOfDate = new ArrayList<LocalDateTime>();//make a new list
		double oprice=0;
		for(Trade t : trades)
		   {
			if(t.sym =="sym") 
			    {
			    //ArrayList<LocalDateTime> listOfDate = new ArrayList<LocalDateTime>();//make a new list
				listOfDate.add(t.datetime);//list of date
				}
			else
			{ 					
				System.out.printf("Not find");

			}
		   }
			Collections.sort(listOfDate);
			refDate=listOfDate.stream().sorted().findFirst().get();
			//listOfDate.stream().sorted(Comparator.reverseOrder()).findFirst().get();
			for(Trade t : trades) 
			{
				if(t.sym =="sym" &&t.datetime == refDate)
				{
					System.out.printf("Open Price is:",+t.price);
					oprice= t.price;
				}
	        }
			return oprice;
			}

	@Override
	public double closePrice(ArrayList<Trade> trades, String sym) {
		// TODO Auto-generated method stub
		//'AT' An automatic trade generated by the SETS system through the order book//use localtime//make a list of dates  and then a stream 
		LocalDateTime refDate = null;
		ArrayList<LocalDateTime> listOfDate = new ArrayList<LocalDateTime>();//make a new list
		double cprice = 0;
		for(Trade t : trades)
		   {
			if(t.sym =="sym") 
			    {
			    //ArrayList<LocalDateTime> listOfDate = new ArrayList<LocalDateTime>();//make a new list
				listOfDate.add(t.datetime);//list of date
				}
			else
			{ 					
				System.out.printf("Not find");

			}
		   }
			Collections.sort(listOfDate);
			//refDate=listOfDate.stream().sorted().findFirst().get();
			listOfDate.stream().sorted(Comparator.reverseOrder()).findFirst().get();
			for(Trade t : trades) {
				if(t.sym =="sym" && t.datetime == refDate)
				{
					System.out.printf("Close Price is:",+t.price);
					cprice=t.price;
				   
				}
		    					 }
			return cprice;
			

			}
	  
	@Override
	public double avgPriceExcludingOpenClose(ArrayList<Trade> trades, String sym) {
		// TODO Auto-generated method stub
		ArrayList<Double> listOfPrices = new ArrayList<Double>();//make a new list
		double cp=closePrice(trades, sym);
		double op=openPrice(trades, sym);
		double sum=0;int count=0;
	    double vol = 0;
	    double avg=0;
		for(Trade t : trades)
		   {
			if(t.sym =="sym") 
			  
				 {
				  sum=sum+t.price;
				  count++;
				  }
			else
			{ 					
				System.out.printf("Not find");

			}
		   } 
		 return avg= (sum-cp-op)/(count-2);

	}

	@Override
	public double vwap(ArrayList<Trade> trades, String sym) {
		// TODO Auto-generated method stub
		ArrayList<Double> listOfPrices = new ArrayList<Double>();//make a new list
		double cp=closePrice(trades, sym);
		double vwap=0;
		double sum=0;int count=0;
		Optional<Double> highprice=Optional.empty();
		double totalvol = 0;
		double hl=0;
		Optional<Double> lowprice=Optional.empty();
		
		for(Trade t : trades)
		   {
			if(t.sym =="sym") 
			  { totalvol=totalvol + t.size;
				listOfPrices.add(t.price);
				highprice=listOfPrices.stream().max(Comparator.comparing(i -> i));
			    lowprice=listOfPrices.stream().min(Comparator.comparing(i -> i));
			 
			  } 
			vwap= (highprice + lowprice + cp)/3*t.size/totalvol; 
		   }
	    return vwap;

}
	@Override
	public void vwapExcludingReportedTrades(ArrayList<Trade> trades, String sym) {
		// TODO Auto-generated method stub

	}

}
